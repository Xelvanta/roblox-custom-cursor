# -*- coding: utf-8 -*-

import base64
import json
import os
import socket
import struct
import subprocess
import sys
import tkinter as tk
import urllib.parse
import webbrowser
import threading
from tkinter import filedialog, messagebox

from PIL import Image, ImageTk

# Uncomment these lines to test enforcement on posix os
# from unittest.mock import patch
# @patch('os.name', 'posix')

# Enforce Windows-only execution
def enforce_nt_os():
    """
    Enforce that the application runs only on Windows (NT-based) operating systems.

    This function checks the operating system and, if it is not Windows, displays an error
    message using a GUI dialog box and then exits the program with a non-zero status code.

    Uses `tkinter` for displaying the error message in a graphical window.

    :raises SystemExit: If the operating system is not Windows (i.e., ``os.name != 'nt'``).
    :rtype: None
    """
    if os.name != "nt":
        root = tk.Tk()
        root.withdraw()
        messagebox.showerror("Error", "This application is only supported on Windows.")
        root.destroy()
        sys.exit(1)

# --- Utility functions ---

def get_abs_path(relative_path):
    base_path = os.path.dirname(sys.executable if getattr(sys, 'frozen', False) else __file__)
    return os.path.abspath(os.path.join(base_path, relative_path))

def find_valid_roblox_version_folder():
    """
    Locate and validate the existence of the Roblox 'Versions' folder on a Windows system.

    This function attempts to construct the path to the Roblox Versions directory within
    the user's local app data directory. If the directory does not exist, it displays
    an error message in a GUI window and exits the program.

    :raises SystemExit: If the Roblox Versions folder is not found.
    :rtype: None
    """
    local_appdata = os.environ.get("LOCALAPPDATA")
    versions_path = os.path.join(local_appdata, "Roblox", "Versions")
    
    if not os.path.isdir(versions_path):
        root = tk.Tk()
        root.withdraw()
        messagebox.showerror("Error", "Roblox Versions folder not found.")
        root.destroy()
        sys.exit(1)

    for subfolder in os.listdir(versions_path):
        full_path = os.path.join(versions_path, subfolder)
        content_path = os.path.join(full_path, "content")
        exe_path = os.path.join(full_path, "RobloxPlayerBeta.exe")

        if os.path.isdir(content_path) and os.path.isfile(exe_path):
            # Uncomment this line as needed to debug the matched folder
            # print(f"Matched folder: {full_path}")
            return full_path

    root = tk.Tk()
    root.withdraw()
    messagebox.showerror("Error", "No valid Roblox version folder found.")
    root.destroy()
    sys.exit(1)

def load_cursor_images(folder_path):
    """
    Load and resize specific cursor images from a given folder.

    This function looks for three specific image files in the specified directory:
    "ArrowFarCursor.png", "ArrowCursor.png", and "IBeamCursor.png". If found, each image
    is resized to 64x64 pixels using LANCZOS resampling and returned with its label and full path.
    If a file is missing, `None` is returned in place of the image.

    :param folder_path: The path to the folder containing the cursor images.
    :type folder_path: str
    :return: A list of tuples, each containing a label (str), a PIL.Image object or None,
             and the full path to the image file.
    :rtype: list[tuple[str, PIL.Image.Image | None, str]]
    """
    filenames = ["ArrowFarCursor.png", "ArrowCursor.png", "IBeamCursor.png"]
    labels = ["Arrow Far", "Arrow", "I-Beam"]
    result = []
    for filename, label in zip(filenames, labels):
        full_path = os.path.join(folder_path, filename)
        if os.path.exists(full_path):
            img = Image.open(full_path).resize((64, 64), Image.Resampling.LANCZOS)
            result.append((label, img, full_path))
        else:
            result.append((label, None, full_path))
    return result

def draw_rounded_rect(canvas, x1, y1, x2, y2, radius=20, **kwargs):
    """
    Draw a rounded rectangle on a tkinter canvas.

    This function creates a polygon that approximates a rectangle with rounded corners
    using B√©zier smoothing. The rectangle is drawn between the points (x1, y1) and (x2, y2),
    with the specified corner radius.

    Additional styling options (such as fill, outline, width, etc.) can be passed
    via keyword arguments and will be forwarded to `canvas.create_polygon`.

    :param canvas: The tkinter canvas to draw on.
    :type canvas: tkinter.Canvas
    :param x1: The x-coordinate of the top-left corner.
    :type x1: int | float
    :param y1: The y-coordinate of the top-left corner.
    :type y1: int | float
    :param x2: The x-coordinate of the bottom-right corner.
    :type x2: int | float
    :param y2: The y-coordinate of the bottom-right corner.
    :type y2: int | float
    :param radius: The radius of the rounded corners. Defaults to 20.
    :type radius: int | float
    :param kwargs: Additional keyword arguments forwarded to `create_polygon`.
    :return: The ID of the created polygon object on the canvas.
    :rtype: int
    """
    points = [
        x1 + radius, y1,
        x2 - radius, y1,
        x2, y1,
        x2, y1 + radius,
        x2, y2 - radius,
        x2, y2,
        x2 - radius, y2,
        x1 + radius, y2,
        x1, y2,
        x1, y2 - radius,
        x1, y1 + radius,
        x1, y1
    ]
    canvas.create_polygon(points, smooth=True, **kwargs)

# Map cursor labels
default_cursor_paths = {
    "Arrow Far": "data/images/ArrowFarCursor.png",
    "Arrow": "data/images/ArrowCursor.png",
    "I-Beam": "data/images/IBeamCursor.png"
}

icon_path = "data/images/RobloxCustomCursorIcon.png"

# --- Main app class ---
class CursorViewerApp(tk.Tk):
    """
    A tkinter-based application to display custom Roblox cursor images.

    This class extends `tk.Tk` to create a GUI application that displays Roblox custom
    cursors, using a tkinter canvas to render images. It initializes the window and sets
    up basic properties like title, geometry, and icon. The `build_ui` method is used to
    construct the user interface.

    :param image_data: The image data to be displayed in the application, typically a
                       list of tuples with cursor labels, images, and file paths.
    :type image_data: list[tuple[str, PIL.Image.Image | None, str]]
    """
    def __init__(self, image_data):
        """
        Initialize the CursorViewerApp window with a title, icon, and a canvas for displaying
        the cursor images.

        :param image_data: The image data to be displayed, containing the images of cursors.
        :type image_data: list[tuple[str, PIL.Image.Image | None, str]]
        """
        super().__init__()
        self.title("Roblox Custom Cursor")
        self.configure(bg="#1e1e1e")
        self.geometry("400x280")
        self.resizable(False, False)

        icon_path = get_abs_path("data/images/RobloxCustomCursorIcon.png")
        self.icon_image = tk.PhotoImage(file=icon_path)
        self.iconphoto(True, self.icon_image)
        
        self.image_refs = []  # Prevent garbage collection
        self.canvas_dict = {}  # Initialize canvas_dict here
        self.build_ui(image_data)

        self.cursor_filenames = ["ArrowFarCursor.png", "ArrowCursor.png", "IBeamCursor.png"]
        self.label_map = {
            "ArrowFarCursor.png": "Arrow Far",
            "ArrowCursor.png": "Arrow",
            "IBeamCursor.png": "I-Beam"
        }

        # Get the latest Roblox path
        folder = find_valid_roblox_version_folder()
        if not folder:
            messagebox.showerror("Error", "Could not find Roblox folder.")
            pass

        self.roblox_cursor_paths = [
            os.path.join(folder, "content", "textures", "Cursors", "KeyboardMouse", fn)
            for fn in self.cursor_filenames
        ]

        self.start_refresh_listener()


    def build_ui(self, image_data):
        """
        Build the user interface for displaying cursor images, labels, and buttons.

        This method creates the main UI components, including a container frame, labels
        for cursor names, canvas widgets for images, and buttons for interacting with
        the cursor files. It also sets up hover and click events for the labels, and
        includes disclaimers and credits.

        :param image_data: The image data to be displayed in the UI, containing cursor labels,
                           images, and file paths.
        :type image_data: list[tuple[str, PIL.Image.Image | None, str]]
        :return: None
        :rtype: None
        """
        container = tk.Frame(self, bg="#1e1e1e")
        container.place(relx=0.5, rely=0.42, anchor="center")

        for index, (label_text, pil_image, filepath) in enumerate(image_data):
            col = index % 3

            # Default label (white text, no underline)
            label = tk.Label(
                container, text=label_text,
                fg="white", bg="#1e1e1e",
                font=("Segoe UI", 10),
                cursor="hand2"
            )
            label.grid(row=0, column=col, pady=(0, 5))

            # Change to folder emoji on hover
            def on_hover_in(event, label=label, label_text=label_text):
                """
                Change the label text to include a folder emoji when the mouse hovers over it.

                :param event: The event object representing the hover event.
                :param label: The label whose text is being modified.
                :param label_text: The original label text to restore when the mouse leaves.
                :return: None
                :rtype: None
                """
                label.config(text="üóÅ " + label_text)

            def on_hover_out(event, label=label, label_text=label_text):
                """
                Restore the original label text when the mouse leaves the label.
    
                :param event: The event object representing the hover-out event.
                :param label: The label whose text is being restored.
                :param label_text: The original label text to restore.
                :return: None
                :rtype: None
                """
                label.config(text=label_text)

            label.bind("<Enter>", on_hover_in)
            label.bind("<Leave>", on_hover_out)

            # Click to open file in Explorer
            label.bind("<Button-1>", lambda e, path=filepath: self.open_in_explorer(path))

            # Canvas with rounded frame, axes, and image
            canvas = tk.Canvas(container, width=100, height=100, bg="#1e1e1e", highlightthickness=0)
            canvas.grid(row=1, column=col, padx=15)

            draw_rounded_rect(canvas, 10, 10, 90, 90, radius=20, fill="#2e2e2e", outline="#444444", width=2)
            canvas.create_line(0, 50, 100, 50, fill="#666666", width=1)
            canvas.create_line(50, 0, 50, 100, fill="#666666", width=1)

            if pil_image:
                tk_img = ImageTk.PhotoImage(pil_image)
                self.image_refs.append(tk_img)
                canvas.create_image(50, 50, image=tk_img)
            else:
                canvas.create_text(50, 50, text="Not found", fill="gray", font=("Arial", 8))

            self.canvas_dict[label_text] = canvas  # Save canvas widget reference

            # Add Change, Default, and Photopea buttons
            self.add_buttons(container, col, filepath, label_text, pil_image)

        # Disclaimer
        disclaimer_label = tk.Label(
            self, text="Roblox Custom Cursor is not affiliated with or endorsed by Photopea",
            fg="#525252", bg="#1e1e1e", font=("Segoe UI", 8)
        )
        disclaimer_label.place(relx=0.5, rely=1, anchor="s")

        # Credits label

        credits_text = "Made with ‚ô° by Xelvanta‚Ñ¢ Softworks"

        credits_label = tk.Label(
            self, text=credits_text,
            fg="#A9A9A9", bg="#1e1e1e", font=("Segoe UI", 8), cursor="heart"
        )
        credits_label.place(relx=0.5, rely=0.95, anchor="s")

        # Make the credits label a clickable link
        credits_label.bind("<Button-1>", lambda e: webbrowser.open("https://github.com/Xelvanta/roblox-custom-cursor"))
        
        # Change font to underlined when hovering and revert when leaving
        credits_label.bind("<Enter>", lambda e: credits_label.config(font=("Segoe UI", 8, "underline"), text="Roblox Custom Cursor GitHub Repository ‚Üó"))
        credits_label.bind("<Leave>", lambda e: credits_label.config(font=("Segoe UI", 8), text=credits_text))

        # Settings button
        settings_button = tk.Button(
        self, text="‚öô", font=("Segoe UI Symbol", 12),
        bg="#1e1e1e", fg="#AAAAAA", bd=0, cursor="hand2",
        command=self.show_settings_window
        )

        settings_button.place(relx=1.0, rely=0.0, anchor="ne", x=0, y=-5)
        settings_button.bind("<Enter>", lambda e: settings_button.config(fg="white"))
        settings_button.bind("<Leave>", lambda e: settings_button.config(fg="#AAAAAA"))

    def add_buttons(self, container, col, filepath, label_text, pil_image):
        """
        Add buttons for changing the cursor image, restoring the default image, and opening
        the cursor image in Photopea for editing.

        This method creates three buttons:
        1. A "Change Cursor" button that allows the user to select a new image to replace the
           existing cursor image.
        2. A "Restore Default" button that restores the original cursor image from base64 data.
        3. A "Edit in Photopea" button that opens the image in Photopea for further editing.

        :param container: The tkinter container widget in which the buttons are placed.
        :type container: tk.Frame
        :param col: The column index where the buttons will be placed in the container.
        :type col: int
        :param filepath: The file path of the cursor image.
        :type filepath: str
        :param label_text: The label text associated with the cursor image.
        :type label_text: str
        :param pil_image: The PIL image object of the cursor.
        :type pil_image: PIL.Image.Image | None
        :return: None
        :rtype: None
        """
        # Change button
        def change_button_action():
            """
            Handle the action for changing the cursor image.
            Prompts the user to select a new image file and updates the cursor image.
            Supports PNG, JPG, CUR, and WEBP formats.
            Converts and resizes to 64x64 PNG.
        
            :return: None
            :rtype: None
            """
            # Allow multiple formats
            new_file = filedialog.askopenfilename(filetypes=[
                ("Image Files", "*.png;*.jpg;*.jpeg;*.cur;*.webp"),
                ("PNG Files", "*.png"),
                ("JPEG Files", "*.jpg;*.jpeg"),
                ("Cursor Files", "*.cur"),
                ("WEBP Files", "*.webp"),
                ("All Files", "*.*")
            ])
        
            if new_file:
                try:
                    img = Image.open(new_file)
        
                    # Resize to 64x64 with good resampling
                    img = img.convert("RGBA").resize((64, 64), Image.Resampling.LANCZOS)
        
                    # Save as PNG (overwrite your destination filepath)
                    img.save(filepath, format="PNG")
        
                    self.update_gui_with_new_image(filepath, label_text)
        
                except Exception as e:
                    messagebox.showerror(
                        "Error",
                        f"Error updating image:\n\n{e}\n\n"
                        "This usually occurs when the Roblox folder or file was moved or deleted during runtime. "
                        "Restarting the application should fix this."
                    )

        change_button = tk.Button(container, text="Change Cursor", command=change_button_action, bg="#444444", fg="white", width=13, cursor="hand2")
        change_button.grid(row=2, column=col, pady=(5, 5))
        change_button.bind("<Enter>", lambda e: change_button.config(bg="#2e2e2e"))
        change_button.bind("<Leave>", lambda e: change_button.config(bg="#444444"))

        # Default button
        def default_button_action():
            """
            Handle the action for restoring the default cursor image.
            Restores the default image from an image file and updates the cursor image.
            """
            try:
                # Get the relative file path for the current label
                relative_img_path = default_cursor_paths.get(label_text)
                if not relative_img_path:
                    raise ValueError(f"No default image file mapped for label '{label_text}'")
        
                # Convert to absolute path relative to this script's directory
                abs_img_path = get_abs_path(relative_img_path)
        
                # Open the image file, resize it, and save to the target filepath
                img = Image.open(abs_img_path).resize((64, 64), Image.Resampling.LANCZOS)
                img.save(filepath)
        
                # Update GUI or state with the new image
                self.update_gui_with_new_image(filepath, label_text)
        
            except Exception as e:
                    messagebox.showerror("Error", f"Error updating image:\n\n{e}\n\n"
                                         "This usually occurs when the Roblox folder or file was moved or deleted during runtime. "
                                         "Restarting the application should fix this.")
        
        # Create the restore default button
        default_button = tk.Button(container, text="Restore Default", command=default_button_action,
                                   bg="#444444", fg="white", width=13, cursor="hand2")
        default_button.grid(row=3, column=col, pady=(0, 5))
        default_button.bind("<Enter>", lambda e: default_button.config(bg="#2e2e2e"))
        default_button.bind("<Leave>", lambda e: default_button.config(bg="#444444"))

        # Photopea button
        def photopea_button_action():
            """
            Handle the action for opening the cursor image in Photopea.
            Converts the cursor image to base64, constructs a URL for Photopea, and opens it in a browser.

            :return: None
            :rtype: None
            """
            # Convert image to base64 and encode it
            with open(filepath, "rb") as img_file:
                img_base64 = base64.b64encode(img_file.read()).decode('utf-8')
            
            config = {
                "files": [
                    f"data:image/png;base64,{img_base64}"
                ],
                "environment": {
                    "eparams": {
                        "guides": True,
                        "grid": True,
                        "gsize": 32,
                        "paths": True,
                        "pgrid": True
                    }
                }
            }

            # Convert the configuration to a JSON string
            config_str = json.dumps(config)

            # URL-encode the JSON string
            encoded_config = urllib.parse.quote(config_str)

            # Construct the Photopea URL
            photopea_url = f"https://www.photopea.com#{encoded_config}"

            # Uncomment this line as needed to debug the encoded URL
            # print("Encoded URL:", photopea_url)

            # Open Photopea in a new browser tab with the encoded JSON URL
            webbrowser.open(photopea_url)

        photopea_button = tk.Button(container, text="Edit in Photopea", command=photopea_button_action, bg="#444444", fg="white", width=13, cursor="hand2")
        photopea_button.grid(row=4, column=col, pady=(0, 5))
        photopea_button.bind("<Enter>", lambda e: photopea_button.config(bg="#2e2e2e"))
        photopea_button.bind("<Leave>", lambda e: photopea_button.config(bg="#444444"))

    def export_cursors_to_rcur(self):
        try:
            # Find Roblox folder
            folder = find_valid_roblox_version_folder()
            # List of cursor filenames in order
            cursor_filenames = ["ArrowFarCursor.png", "ArrowCursor.png", "IBeamCursor.png"]
            cursor_images = []

            for filename in cursor_filenames:
                filepath = os.path.join(folder, "content", "textures", "Cursors", "KeyboardMouse", filename)
                if not os.path.isfile(filepath):
                    raise FileNotFoundError(f"Cursor file missing: {filename}")
                with open(filepath, "rb") as f:
                    cursor_images.append(f.read())

            # Ask user where to save the file
            save_path = filedialog.asksaveasfilename(
                defaultextension=".rcur",
                filetypes=[("Roblox Custom Cursor Profile", "*.rcur"), ("All Files", "*.*")],
                initialfile="roblox_custom_cursor_profile",
                title="Save exported cursors as"
            )
            if not save_path:
                return

            # Write binary .rcur file
            with open(save_path, "wb") as out_file:
                # Write magic header
                out_file.write(b"RCUR\x00")
                # Write version number (4 bytes, little endian)
                out_file.write(struct.pack("<I", 2))  # version 2
                # Write lengths of each PNG image (4 bytes each)
                for img in cursor_images:
                    out_file.write(struct.pack("<I", len(img)))
                # Write PNG image data consecutively
                for img in cursor_images:
                    out_file.write(img)

            messagebox.showinfo("Success", "Cursors exported successfully.")
        except Exception as e:
            messagebox.showerror("Error", str(e))

    def import_cursors_from_rcur(self):
        from tkinter import filedialog

        folder = find_valid_roblox_version_folder()
        if not folder:
            tk.Tk().withdraw()
            messagebox.showerror("Roblox Folder Not Found", "Unable to locate a valid Roblox installation folder.")
            return

        cursor_filenames = ["ArrowFarCursor.png", "ArrowCursor.png", "IBeamCursor.png"]
        cursor_paths = [os.path.join(folder, "content", "textures", "Cursors", "KeyboardMouse", fn) for fn in cursor_filenames]

        MAGIC_HEADER = b"RCUR\x00"
        EXPECTED_VERSION = 2

        try:
            import_path = filedialog.askopenfilename(
                filetypes=[("Roblox Custom Cursor Profile", "*.rcur"), ("All Files", "*.*")],
                title="Select .rcur file to import"
            )
            if not import_path:
                return  # Cancelled

            with open(import_path, "rb") as f:
                magic = f.read(5)
                if magic != MAGIC_HEADER:
                    raise ValueError(
                        "The selected .rcur file is using a legacy format (base64). Legacy base64-encoded .rcur files are no longer supported."
                    )

                version_bytes = f.read(4)
                if len(version_bytes) < 4:
                    raise ValueError("The .rcur file is corrupt or incomplete (missing version number).")

                version = struct.unpack("<I", version_bytes)[0]
                if version != EXPECTED_VERSION:
                    raise ValueError(f"Unsupported .rcur version: {version}.")

                lengths = []
                for _ in range(3):
                    len_bytes = f.read(4)
                    if len(len_bytes) < 4:
                        raise ValueError("Corrupt file: missing image length information.")
                    lengths.append(struct.unpack("<I", len_bytes)[0])

                for i, length in enumerate(lengths):
                    image_data = f.read(length)
                    if len(image_data) != length:
                        raise ValueError("Corrupt file: one or more cursor images are incomplete.")

                    with open(cursor_paths[i], "wb") as img_file:
                        img_file.write(image_data)

                    label_map = {
                        "ArrowFarCursor.png": "Arrow Far",
                        "ArrowCursor.png": "Arrow",
                        "IBeamCursor.png": "I-Beam"
                    }
                    label_text = label_map[cursor_filenames[i]]
                    self.update_gui_with_new_image(cursor_paths[i], label_text)

            tk.Tk().withdraw()
            messagebox.showinfo("Success", "Cursors imported and applied successfully.")

        except Exception as e:
            tk.Tk().withdraw()
            messagebox.showerror("Import Failed", str(e))

    def show_settings_window(self):
        settings_win = tk.Toplevel(self)
        settings_win.title("Settings")
        settings_win.configure(bg="#1e1e1e")
        settings_win.geometry("300x270")
        settings_win.resizable(False, False)

        tk.Label(settings_win, text="Settings", font=("Segoe UI", 12, "bold"),
                 fg="white", bg="#1e1e1e").pack(pady=15)

        def create_button_with_info(parent, text, command, tooltip_text):
            container = tk.Frame(parent, bg="#1e1e1e")
            container.pack(pady=3)

            btn = tk.Button(container, text=text,
                            command=command,
                            bg="#444444", fg="white", cursor="hand2", width=25)
            btn.pack(side="left")
            btn.bind("<Enter>", lambda e: btn.config(bg="#2e2e2e"))
            btn.bind("<Leave>", lambda e: btn.config(bg="#444444"))
        
            info_label = tk.Label(container, text="üõà", font=("Segoe UI", 12),
                                  fg="white", bg="#1e1e1e", cursor="question_arrow")
            info_label.pack(side="left", padx=3)

            # Attach tooltip to info_label
            ToolTip(info_label, tooltip_text)

            container.pack_configure(anchor="center")

            return btn, info_label

        export_btn, export_info = create_button_with_info(settings_win, "Export Cursors as Profile", self.export_cursors_to_rcur, "Export your currently applied cursors as a Roblox Custom Cursor Profile (.rcur) file.\nThis file can be shared or imported later to restore your full cursor set.")
        import_btn, import_info = create_button_with_info(settings_win, "Import Cursors from Profile", self.import_cursors_from_rcur, "Import cursors from an existing Roblox Custom Cursor Profile (.rcur) file.\nThis will replace your currently applied cursor set with the full set from the profile.")

        # Report a bug label

        bug_text = "Report a Bug or Request a Feature"

        bug_label = tk.Label(
            settings_win, text=bug_text,
            fg="#A9A9A9", bg="#1e1e1e", font=("Segoe UI", 8), cursor="hand2"
        )
        bug_label.place(relx=0.5, rely=0.98, anchor="s")

        # Make the bug label a clickable link
        bug_label.bind("<Button-1>", lambda e: webbrowser.open("https://github.com/Xelvanta/roblox-custom-cursor/issues/new"))
        
        bug_label.bind("<Enter>", lambda e: bug_label.config(font=("Segoe UI", 8, "underline"), text=bug_text + " ‚Üó"))
        bug_label.bind("<Leave>", lambda e: bug_label.config(font=("Segoe UI", 8), text=bug_text))

        close_btn = tk.Button(settings_win, text="Close", command=settings_win.destroy,
                          bg="#444444", fg="white", cursor="hand2")
        close_btn.pack(pady=20)
        close_btn.bind("<Enter>", lambda e: close_btn.config(bg="#2e2e2e"))
        close_btn.bind("<Leave>", lambda e: close_btn.config(bg="#444444"))

    def update_gui_with_new_image(self, filepath, label_text):
        """
        Reload the image from the specified file path and update the GUI with the new image.

        This method opens the image file at the given path, resizes it to 64x64 pixels, and updates
        the canvas associated with the given label text. It first clears any existing content in
        the canvas and then draws a rounded rectangle with the new image centered within it.

        :param filepath: The path to the image file that will be loaded and displayed.
        :type filepath: str
        :param label_text: The label text that identifies the canvas to be updated.
        :type label_text: str
        :return: None
        :rtype: None
        """
        # Reload the image and update GUI
        pil_image = Image.open(filepath).resize((64, 64), Image.Resampling.LANCZOS)
        tk_img = ImageTk.PhotoImage(pil_image)
        self.image_refs.append(tk_img)

        # Update the canvas associated with the label
        canvas = self.canvas_dict.get(label_text)
        if canvas:
            canvas.delete("all")  # Clear the existing content
            draw_rounded_rect(canvas, 10, 10, 90, 90, radius=20, fill="#2e2e2e", outline="#444444", width=2)
            canvas.create_line(0, 50, 100, 50, fill="#666666", width=1)
            canvas.create_line(50, 0, 50, 100, fill="#666666", width=1)
            canvas.create_image(50, 50, image=tk_img)

    def open_in_explorer(self, filepath):
        """
        Open the file or folder in Windows Explorer, selecting the specified file.

        If the file path exists, this method opens Windows Explorer and selects the file at the
        given path. If the file does not exist, an error message is displayed indicating the issue.

        :param filepath: The path to the file or folder to be opened and selected in Explorer.
        :type filepath: str
        :return: None
        :rtype: None
        """
        if os.path.exists(filepath):
            subprocess.run(['explorer', '/select,', os.path.normpath(filepath)])
        else:
            messagebox.showerror("Error", "Error showing image in explorer:\n\nFile or folder not found during runtime.\n\n"
                                           "This usually occurs when the Roblox folder or file was moved or deleted during runtime. "
                                           "Restarting the application should fix this.")

    def refresh_all_images(self):
        for i, filename in enumerate(self.cursor_filenames):
            label_text = self.label_map[filename]
            filepath = self.roblox_cursor_paths[i]
            if os.path.exists(filepath):
                self.update_gui_with_new_image(filepath, label_text)

    def start_refresh_listener(self):
        HOST = '127.0.0.1'
        PORT = 57623

        def listener():
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.bind((HOST, PORT))
                    s.listen()
                    while True:
                        conn, _ = s.accept()
                        with conn:
                            message = conn.recv(1024).decode()
                            if message.strip() == "refresh_cursors":
                                self.refresh_all_images()
            except OSError:
                # Port already in use ‚Äî skip listener
                pass

        threading.Thread(target=listener, daemon=True).start()

class ToolTip:
    def __init__(self, widget, text):
        self.widget = widget
        self.text = text
        self.tipwindow = None
        self.id = None
        self.x = self.y = 0
        widget.bind("<Enter>", self.show_tip)
        widget.bind("<Leave>", self.hide_tip)

    def show_tip(self, event=None):
        if self.tipwindow or not self.text:
            return
        x = self.widget.winfo_rootx() + 20
        y = self.widget.winfo_rooty() + self.widget.winfo_height() + 5
        self.tipwindow = tw = tk.Toplevel(self.widget)
        tw.wm_overrideredirect(True)  # Remove window decorations
        tw.wm_geometry(f"+{x}+{y}")
        label = tk.Label(tw, text=self.text, justify='left',
                         background="#333333", fg="white", relief='solid', borderwidth=1,
                         font=("Segoe UI", 9))
        label.pack(ipadx=5, ipady=2)

    def hide_tip(self, event=None):
        tw = self.tipwindow
        self.tipwindow = None
        if tw:
            tw.destroy()

# --- Entry point (definitely not a roblox reference) ---

def main():
    """
    Main entry point for the application.

    This function attempts to find a valid Roblox version folder and load the cursor images 
    from the relevant directory. If a valid version folder is found, the `CursorViewerApp` is 
    initialized and started. If no valid folder is found, an error message is displayed.

    The flow of this function is as follows:
    1. It checks for a valid Roblox version folder using `find_valid_roblox_version_folder()`.
    2. If no valid folder is found, an error message is shown and the function exits.
    3. If a valid folder is found, it loads the cursor images from the `KeyboardMouse` directory.
    4. The `CursorViewerApp` is created and the application starts running.

    :return: None
    :rtype: None
    """
    version_folder = find_valid_roblox_version_folder()
    if not version_folder:
        messagebox.showerror("Error", "Could not find a valid Roblox version folder.")
        return

    cursor_folder = os.path.join(version_folder, "content", "textures", "Cursors", "KeyboardMouse")
    image_data = load_cursor_images(cursor_folder)

    app = CursorViewerApp(image_data)
    app.mainloop()

if __name__ == "__main__":
    enforce_nt_os()
    main()
